#ifndef __UNIVERSAL_KEPLER_SOLVER_H__
#define __UNIVERSAL_KEPLER_SOLVER_H__

#include "common.h"


#ifdef CONFIG_USE_DOUBLE
    #define TOLERANCE ((REAL)(2.2737367544323205948e-13))     // 2^(-42)
#else
    #define TOLERANCE ((REAL)(1.52587890625e-5))              // (2^-16)
#endif
#define MAXITER 64
#define COMPARE(x, y) (((x) > (y)) - ((x) < (y)))
#define SIGN(x) COMPARE(x, 0)


static inline REAL stumpff_c0(
//    const REAL zeta)
    REAL zeta)      // This is because of bug 4775 on old versions of glibc.
                    // That bug has already been fixed in latter versions.
{
    REAL abs_zeta = fabs(zeta);
    if (abs_zeta < 1) {
        /* Taylor series: 1 + z / 2 + z*z / 24 + z*z*z / 720 + ...
         *
         * Horner form: ((... + 1) * z / 12 + 1) * z / 2 + 1
         *
         * The i-th coefficient for Horner form is generated by:
         *
         * a_i = (2*i+2)! / (2*i)!
         */
        return ((((((((((
          zeta / 380 + 1)
        * zeta / 306 + 1)
        * zeta / 240 + 1)
        * zeta / 182 + 1)
        * zeta / 132 + 1)
        * zeta / 90  + 1)
        * zeta / 56  + 1)
        * zeta / 30  + 1)
        * zeta / 12  + 1)
        * zeta / 2   + 1);
    }

    REAL sz = sqrt(abs_zeta);
    if (zeta < 0) {
        return cos(sz);
    }
    return cosh(sz);
}


static inline REAL stumpff_c1(
//    const REAL zeta)
    REAL zeta)
{
    REAL abs_zeta = fabs(zeta);
    if (abs_zeta < 1) {
        /* Taylor series: 1 + z / 6 + z*z / 120 + z*z*z / 5040 + ...
         *
         * Horner form: ((... + 1) * z / 20 + 1) * z / 6 + 1
         *
         * The i-th coefficient for Horner form is generated by:
         *
         * a_i = (2*i+3)! / (2*i+1)!
         */
        return ((((((((((
              zeta / 420 + 1)
            * zeta / 342 + 1)
            * zeta / 272 + 1)
            * zeta / 210 + 1)
            * zeta / 156 + 1)
            * zeta / 110 + 1)
            * zeta / 72  + 1)
            * zeta / 42  + 1)
            * zeta / 20  + 1)
            * zeta / 6   + 1);
    }

    REAL sz = sqrt(abs_zeta);
    if (zeta < 0) {
        return sin(sz) / sz;
    }
    return sinh(sz) / sz;
}


static inline REAL stumpff_c2(
//    const REAL zeta)
    REAL zeta)
{
    REAL abs_zeta = fabs(zeta);
    if (abs_zeta < 1) {
        /* stumpff_c2(z) = (stumpff_c0(z) - 1) / z
         */
        return (((((((((
              zeta / 380 + 1)
            * zeta / 306 + 1)
            * zeta / 240 + 1)
            * zeta / 182 + 1)
            * zeta / 132 + 1)
            * zeta / 90  + 1)
            * zeta / 56  + 1)
            * zeta / 30  + 1)
            * zeta / 12  + 1) / 2;
    }

    REAL sz = sqrt(abs_zeta);
    if (zeta < 0) {
        return (cos(sz) - 1) / zeta;
    }
    return (cosh(sz) - 1) / zeta;
}


static inline REAL stumpff_c3(
//    const REAL zeta)
    REAL zeta)
{
    REAL abs_zeta = fabs(zeta);
    if (abs_zeta < 1) {
        /* stumpff_c3(z) = (stumpff_c1(z) - 1) / z
         */
        return (((((((((
              zeta / 420 + 1)
            * zeta / 342 + 1)
            * zeta / 272 + 1)
            * zeta / 210 + 1)
            * zeta / 156 + 1)
            * zeta / 110 + 1)
            * zeta / 72  + 1)
            * zeta / 42  + 1)
            * zeta / 20  + 1) / 6;
    }

    REAL sz = sqrt(abs_zeta);
    if (zeta < 0) {
        return (sin(sz) / sz - 1) / zeta;
    }
    return (sinh(sz) / sz - 1) / zeta;
}


static inline REAL S0(
    const REAL s,
    const REAL alpha)
{
    REAL s2 = s * s;
    REAL zeta = alpha * s2;
    return stumpff_c0(zeta);
}


static inline REAL S1(
    const REAL s,
    const REAL alpha)
{
    REAL s2 = s * s;
    REAL zeta = alpha * s2;
    return s * stumpff_c1(zeta);
}


static inline REAL S2(
    const REAL s,
    const REAL alpha)
{
    REAL s2 = s * s;
    REAL zeta = alpha * s2;
    return s2 * stumpff_c2(zeta);
}


static inline REAL S3(
    const REAL s,
    const REAL alpha)
{
    REAL s2 = s * s;
    REAL s3 = s * s2;
    REAL zeta = alpha * s2;
    return s3 * stumpff_c3(zeta);
}


static inline REAL lagrange_f(
    const REAL s,
    const REAL r0,
    const REAL m,
    const REAL alpha)
{
    return 1 - m * S2(s, alpha) / r0;
}


static inline REAL lagrange_g(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL alpha)
{
//    return r0 * s + r0v0 * S2(s, alpha) + (alpha * r0) * S3(s, alpha);
    return r0 * S1(s, alpha) + r0v0 * S2(s, alpha);
}


static inline REAL lagrange_dfds(
    const REAL s,
    const REAL r0,
    const REAL m,
    const REAL alpha)
{
    return -m * S1(s, alpha) / r0;
}


static inline REAL lagrange_dgds(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL alpha)
{
//    return r0 + r0v0 * S1(s, alpha) + (alpha * r0) * S2(s, alpha);
    return r0 * S0(s, alpha) + r0v0 * S1(s, alpha);
}


static inline REAL universal_kepler(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL m,
    const REAL alpha)
{
//    return r0 * S1(s, alpha) + r0v0 * S2(s, alpha) + m * S3(s, alpha);
    return r0 * s + r0v0 * S2(s, alpha) + (m + alpha * r0) * S3(s, alpha);
}


static inline REAL universal_kepler_ds(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL m,
    const REAL alpha)
{
//    return r0 * S0(s, alpha) + r0v0 * S1(s, alpha) + m * S2(s, alpha);
    return r0 + r0v0 * S1(s, alpha) + (m + alpha * r0) * S2(s, alpha);
}


static inline REAL universal_kepler_dsds(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL m,
    const REAL alpha)
{
//    return r0v0 * S0(s, alpha) + (m + alpha * r0) * S1(s, alpha);
    return r0v0 * S0(s, alpha) + (m + alpha * r0) * S1(s, alpha);
}


static inline REAL f(
    const REAL s,
    REAL *arg)
{
    return universal_kepler(s, arg[1], arg[2], arg[3], arg[4]) - arg[0];
}


static inline REAL fprime(
    const REAL s,
    REAL *arg)
{
    return universal_kepler_ds(s, arg[1], arg[2], arg[3], arg[4]);
}


static inline REAL fprimeprime(
    const REAL s,
    REAL *arg)
{
    return universal_kepler_dsds(s, arg[1], arg[2], arg[3], arg[4]);
}


#define ORDER 5
static inline REAL laguerre(
    const REAL s,
    REAL *arg)
{
    REAL fv = f(s, arg);
    REAL dfv = fprime(s, arg);
    REAL ddfv = fprimeprime(s, arg);
    REAL a = dfv;
    REAL a2 = a * a;
    REAL b = a2 - fv * ddfv;
    REAL g = ORDER * fv;
    REAL h = a + SIGN(a) * sqrt(fabs((ORDER - 1) * (ORDER * b - a2)));

    return -g / h;
}


static inline REAL halley(
    const REAL s,
    REAL *arg)
{
    REAL fv = f(s, arg);
    REAL dfv = fprime(s, arg);
    REAL ddfv = fprimeprime(s, arg);
    REAL g = 2 * fv * dfv;
    REAL h = (2 * dfv * dfv - fv * ddfv);

    return -g / h;
}


static inline REAL newton(
    const REAL s,
    REAL *arg)
{
    REAL fv = f(s, arg);
    REAL dfv = fprime(s, arg);
    REAL g = fv;
    REAL h = dfv;

    return -g / h;
}


static inline REAL fdelta(
    const REAL s,
    REAL *arg)
{
//    return newton(s, arg);
//    return halley(s, arg);
    return laguerre(s, arg);
}


static inline INT findroot(
    REAL x0,
    REAL *x,
    REAL *arg)
{
    INT i = 0;
    REAL a, b;

    *x = x0;
    do {
        if (i > MAXITER) return -1;
        REAL delta = fdelta(*x, arg);
        if (fabs(delta) > fabs(*x))
            delta = SIGN(delta) * fabs((*x)/2);

        i += 1;
        a = (*x);
        (*x) += delta;
        b = (*x);
    } while (2 * fabs(b - a) > TOLERANCE * fabs(a + b));

    return 0;
}


static inline void set_new_pos_vel(
    const REAL s,
    const REAL r0,
    const REAL r0v0,
    const REAL m,
    const REAL e2,
    const REAL alpha,
    REAL *rx,
    REAL *ry,
    REAL *rz,
    REAL *vx,
    REAL *vy,
    REAL *vz)
{
    REAL r0x = *rx;
    REAL r0y = *ry;
    REAL r0z = *rz;
    REAL v0x = *vx;
    REAL v0y = *vy;
    REAL v0z = *vz;

    REAL lf = lagrange_f(s, r0, m, alpha);
    REAL lg = lagrange_g(s, r0, r0v0, alpha);
    REAL r1x, r1y, r1z;
    r1x = r0x * lf + v0x * lg;
    r1y = r0y * lf + v0y * lg;
    r1z = r0z * lf + v0z * lg;

//    REAL r1 = sqrt(e2 + r1x * r1x + r1y * r1y + r1z * r1z);
    REAL r1 = universal_kepler_ds(s, r0, r0v0, m, alpha);

    REAL ldf = lagrange_dfds(s, r0, m, alpha) / r1;
    REAL ldg = lagrange_dgds(s, r0, r0v0, alpha) / r1;
//    REAL ldg = (1 + lg * ldf) / lf;
//    REAL ldf = (lf * ldg - 1) / lg;
    REAL v1x, v1y, v1z;
    v1x = r0x * ldf + v0x * ldg;
    v1y = r0y * ldf + v0y * ldg;
    v1z = r0z * ldf + v0z * ldg;

    *rx = r1x;
    *ry = r1y;
    *rz = r1z;
    *vx = v1x;
    *vy = v1y;
    *vz = v1z;
}


static inline INT _universal_kepler_solver(
    const REAL dt0,
    const REAL m,
    const REAL e2,
    const REAL r0x,
    const REAL r0y,
    const REAL r0z,
    const REAL v0x,
    const REAL v0y,
    const REAL v0z,
    REAL *r1x,
    REAL *r1y,
    REAL *r1z,
    REAL *v1x,
    REAL *v1y,
    REAL *v1z)
{
    REAL rx = r0x;
    REAL ry = r0y;
    REAL rz = r0z;
    REAL vx = v0x;
    REAL vy = v0y;
    REAL vz = v0z;

    REAL r2 = rx * rx + ry * ry + rz * rz;
    INT mask = (r2 > 0);
    if (!mask) {
        *r1x = rx;
        *r1y = ry;
        *r1z = rz;
        *v1x = vx;
        *v1y = vy;
        *v1z = vz;
        return 0;
    }
    r2 += e2;
    REAL r = sqrt(r2);

    REAL v2 = vx * vx + vy * vy + vz * vz;
    REAL rv = rx * vx + ry * vy + rz * vz;
    REAL beta = 2 - (e2 / r2);
    REAL alpha = v2 - beta * m / r;
    REAL abs_alpha = fabs(alpha);

    REAL s0, s, arg[5];

    REAL dt = dt0;

    /* First guess for highly hyperbolic orbits:
     * adapted from formula 4.5.11 in fundamentals
     * of astrodynamics (Bate et al. 1971).
     */
    REAL ss = (2 * alpha * fabs(dt0 / (rv + (m + alpha * r) / sqrt(abs_alpha))));
    if (ss > 1) {
        s0 = SIGN(dt0) * log(ss) / sqrt(abs_alpha);
    } else {
        /* For elliptical orbits: reduce the time
         * step to a fraction of the orbital period.
         */
        if (alpha < 0) {
            REAL a = m / abs_alpha;
            REAL T = 2 * PI * a * sqrt(a / m);
            REAL ratio = dt0 / T;
            dt = (ratio - (INT)(ratio)) * T;
        }
        /* This seems to work well for both
         * elliptical and nearly parabolical
         * orbits.
         */
        s0 = dt * abs_alpha / (beta * m);

        REAL s01 = dt / r;
        if (fabs(alpha * s01 * s01) < 1)
            s0 = s01;
    }

    arg[0] = dt;
    arg[1] = r;
    arg[2] = rv;
    arg[3] = m;
    arg[4] = alpha;

    INT err = findroot(s0, &s, arg);
    if (err == 0) {
        set_new_pos_vel(s, r, rv, m, e2, alpha,
                        &rx, &ry, &rz, &vx, &vy, &vz);
    } else {
        #ifndef CONFIG_USE_OPENCL
        fprintf(stderr, "#---err: %ld\n", (long)(err));
        fprintf(stderr,
            "#   dt0: %e, m: %e, e2: %e,"
            " r0x: %e, r0y: %e, r0z: %e,"
            " v0x: %e, v0y: %e, v0z: %e\n"
            "#   dt: %e, r: %e, rv: %e,"
            " alpha: %e, s0: %e, s: %e, ss: %e\n",
            (double)(dt0), (double)(m), (double)(e2),
            (double)(r0x), (double)(r0y), (double)(r0z),
            (double)(v0x), (double)(v0y), (double)(v0z),
            (double)(dt), (double)(r), (double)(rv),
            (double)(alpha), (double)(s0), (double)(s), (double)(ss));
        fprintf(stderr, "#---\n");
        #endif

/*
        rx = r0x;
        ry = r0y;
        rz = r0z;
        vx = v0x;
        vy = v0y;
        vz = v0z;
        __universal_kepler_solver(dt/2, m, e2,
                                  rx, ry, rz, vx, vy, vz,
                                  &rx, &ry, &rz, &vx, &vy, &vz);
        __universal_kepler_solver(dt/2, m, e2,
                                  rx, ry, rz, vx, vy, vz,
                                  &rx, &ry, &rz, &vx, &vy, &vz);
*/
    }

    *r1x = rx;
    *r1y = ry;
    *r1z = rz;
    *v1x = vx;
    *v1y = vy;
    *v1z = vz;
    return err;
}


static inline void __universal_kepler_solver(
    const REAL dt,
    const REAL m,
    const REAL e2,
    const REAL r0x,
    const REAL r0y,
    const REAL r0z,
    const REAL v0x,
    const REAL v0y,
    const REAL v0z,
    REAL *r1x,
    REAL *r1y,
    REAL *r1z,
    REAL *v1x,
    REAL *v1y,
    REAL *v1z)
{
    INT i, n = 1;
    REAL rx, ry, rz, vx, vy, vz;

label1:
    rx = r0x;
    ry = r0y;
    rz = r0z;
    vx = v0x;
    vy = v0y;
    vz = v0z;
    for (i = 0; i < n; ++i) {
        INT err = _universal_kepler_solver(dt/n, m, e2, rx, ry, rz, vx, vy, vz,
                                           &rx, &ry, &rz, &vx, &vy, &vz);
        if (err != 0) {
            n *= 2;
            goto label1;
        }
    }
    *r1x = rx;
    *r1y = ry;
    *r1z = rz;
    *v1x = vx;
    *v1y = vy;
    *v1z = vz;
}


static inline void universal_kepler_solver(
    const REAL dt,
    const REAL m,
    const REAL e2,
    const REAL r0x,
    const REAL r0y,
    const REAL r0z,
    const REAL v0x,
    const REAL v0y,
    const REAL v0z,
    REAL *r1x,
    REAL *r1y,
    REAL *r1z,
    REAL *v1x,
    REAL *v1y,
    REAL *v1z)
{
    REAL rx, ry, rz, vx, vy, vz;

    __universal_kepler_solver(dt, m, e2,
                              r0x, r0y, r0z, v0x, v0y, v0z,
                              &rx, &ry, &rz, &vx, &vy, &vz);

    if (e2 == 0) {
        *r1x = rx;
        *r1y = ry;
        *r1z = rz;
        *v1x = vx;
        *v1y = vy;
        *v1z = vz;
        return;
    }

    REAL r2 = r0x * r0x + r0y * r0y + r0z * r0z;
    INT mask = (r2 > 0);
    if (!mask) {
        *r1x = r0x;
        *r1y = r0y;
        *r1z = r0z;
        *v1x = v0x;
        *v1y = v0y;
        *v1z = v0z;
        return;
    }
    r2 += e2;
    REAL r = sqrt(r2);
    REAL v2 = v0x * v0x + v0y * v0y + v0z * v0z;
    REAL u0 = 2 * m / r;
    REAL e0 = v2 - u0;

    r2 = rx * rx + ry * ry + rz * rz;
    r2 += e2;
    r = sqrt(r2);
    v2 = vx * vx + vy * vy + vz * vz;
    REAL u1 = 2 * m / r;
    REAL e1 = v2 - u1;

    INT n = 1;
    REAL tol = 64*TOLERANCE;
    REAL err = fabs(e1 - e0);
    if (2*err < tol * (u1+u0)) {
        *r1x = rx;
        *r1y = ry;
        *r1z = rz;
        *v1x = vx;
        *v1y = vy;
        *v1z = vz;
        return;
    }

label1:

    n *= 2;
    rx = r0x;
    ry = r0y;
    rz = r0z;
    vx = v0x;
    vy = v0y;
    vz = v0z;

    INT i;
    for (i = 0; i < n; ++i) {
        __universal_kepler_solver(dt/n, m, e2, rx, ry, rz, vx, vy, vz,
                                  &rx, &ry, &rz, &vx, &vy, &vz);

        r2 = rx * rx + ry * ry + rz * rz;
        r2 += e2;
        r = sqrt(r2);
        v2 = vx * vx + vy * vy + vz * vz;
        u1 = 2 * m / r;
        e1 = v2 - u1;

        err = fabs(e1 - e0);
        if (2*err > tol * (u1+u0)) {
            goto label1;
        }
    }

    *r1x = rx;
    *r1y = ry;
    *r1z = rz;
    *v1x = vx;
    *v1y = vy;
    *v1z = vz;
}

#endif  // __UNIVERSAL_KEPLER_SOLVER_H__
